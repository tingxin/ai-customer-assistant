# çŸ¥è¯†åº“æ•°æ®æ¨¡å‹è®¾è®¡

## ğŸ¯ ç›®æ ‡
åŸºäºå¼€å‘æ–‡æ¡£çš„ERå…³ç³»å›¾ï¼Œè®¾è®¡çŸ¥è¯†åº“ç›¸å…³çš„æ•°æ®æ¨¡å‹å’Œæ•°æ®åº“è¡¨ç»“æ„ã€‚

## ğŸ“‹ å‰ç½®æ¡ä»¶
- PostgreSQLæ•°æ®åº“å·²å®‰è£…
- SQLAlchemyå·²é…ç½®

## ğŸ—„ï¸ æ•°æ®æ¨¡å‹è®¾è®¡

### 1. æ ¸å¿ƒå®ä½“å…³ç³»
```
KnowledgeBase (çŸ¥è¯†åº“) 1:N Document (æ–‡æ¡£) 1:N DocumentChunk (æ–‡æ¡£å—) 1:1 VectorEmbedding (å‘é‡)
```

### 2. åˆ›å»ºæ•°æ®æ¨¡å‹æ–‡ä»¶

åˆ›å»º `backend/app/models/knowledge.py`ï¼š
```python
from sqlalchemy import Column, String, Text, Integer, DateTime, ForeignKey, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid
import enum
from .database import Base

class KnowledgeBaseStatus(str, enum.Enum):
    ACTIVE = "active"
    INACTIVE = "inactive" 
    DELETED = "deleted"

class DocumentStatus(str, enum.Enum):
    UPLOADED = "uploaded"
    PROCESSING = "processing"
    PROCESSED = "processed"
    FAILED = "failed"

class DocumentType(str, enum.Enum):
    PDF = "pdf"
    WORD = "word"
    TXT = "txt"
    MARKDOWN = "markdown"

class KnowledgeBase(Base):
    __tablename__ = "knowledge_bases"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(100), nullable=False)
    description = Column(Text)
    owner_id = Column(UUID(as_uuid=True), nullable=False)
    status = Column(Enum(KnowledgeBaseStatus), default=KnowledgeBaseStatus.ACTIVE)
    document_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # å…³ç³»
    documents = relationship("Document", back_populates="knowledge_base", cascade="all, delete-orphan")

class Document(Base):
    __tablename__ = "documents"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    knowledge_base_id = Column(UUID(as_uuid=True), ForeignKey("knowledge_bases.id"), nullable=False)
    title = Column(String(200), nullable=False)
    content = Column(Text)
    doc_type = Column(Enum(DocumentType), nullable=False)
    status = Column(Enum(DocumentStatus), default=DocumentStatus.UPLOADED)
    file_path = Column(String(500))
    file_size = Column(Integer)
    created_at = Column(DateTime, default=datetime.utcnow)
    processed_at = Column(DateTime)
    
    # å…³ç³»
    knowledge_base = relationship("KnowledgeBase", back_populates="documents")
    chunks = relationship("DocumentChunk", back_populates="document", cascade="all, delete-orphan")

class DocumentChunk(Base):
    __tablename__ = "document_chunks"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    document_id = Column(UUID(as_uuid=True), ForeignKey("documents.id"), nullable=False)
    content = Column(Text, nullable=False)
    chunk_index = Column(Integer, nullable=False)
    vector_id = Column(String(100))  # ChromaDBä¸­çš„å‘é‡ID
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # å…³ç³»
    document = relationship("Document", back_populates="chunks")
```

### 3. åˆ›å»ºPydanticæ¨¡å¼

åˆ›å»º `backend/app/schemas/knowledge.py`ï¼š
```python
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from enum import Enum

class KnowledgeBaseStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    DELETED = "deleted"

class DocumentStatus(str, Enum):
    UPLOADED = "uploaded"
    PROCESSING = "processing"
    PROCESSED = "processed"
    FAILED = "failed"

class DocumentType(str, Enum):
    PDF = "pdf"
    WORD = "word"
    TXT = "txt"
    MARKDOWN = "markdown"

# çŸ¥è¯†åº“æ¨¡å¼
class KnowledgeBaseCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    description: Optional[str] = None

class KnowledgeBaseUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = None
    status: Optional[KnowledgeBaseStatus] = None

class KnowledgeBaseResponse(BaseModel):
    id: str
    name: str
    description: Optional[str]
    owner_id: str
    status: KnowledgeBaseStatus
    document_count: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

# æ–‡æ¡£æ¨¡å¼
class DocumentResponse(BaseModel):
    id: str
    title: str
    doc_type: DocumentType
    status: DocumentStatus
    file_size: Optional[int]
    created_at: datetime
    processed_at: Optional[datetime]
    
    class Config:
        from_attributes = True
```

### 4. æ•°æ®åº“è¿ç§»è„šæœ¬

åˆ›å»º `backend/scripts/create_knowledge_tables.py`ï¼š
```python
from app.models.database import engine, Base
from app.models.knowledge import KnowledgeBase, Document, DocumentChunk

def create_knowledge_tables():
    """åˆ›å»ºçŸ¥è¯†åº“ç›¸å…³è¡¨"""
    try:
        # åˆ›å»ºè¡¨
        Base.metadata.create_all(bind=engine, tables=[
            KnowledgeBase.__table__,
            Document.__table__,
            DocumentChunk.__table__
        ])
        print("âœ… çŸ¥è¯†åº“è¡¨åˆ›å»ºæˆåŠŸ")
        
        # åˆ›å»ºç´¢å¼•
        from sqlalchemy import text
        with engine.connect() as conn:
            # çŸ¥è¯†åº“ç´¢å¼•
            conn.execute(text("CREATE INDEX IF NOT EXISTS idx_kb_owner ON knowledge_bases(owner_id)"))
            conn.execute(text("CREATE INDEX IF NOT EXISTS idx_kb_status ON knowledge_bases(status)"))
            
            # æ–‡æ¡£ç´¢å¼•
            conn.execute(text("CREATE INDEX IF NOT EXISTS idx_doc_kb ON documents(knowledge_base_id)"))
            conn.execute(text("CREATE INDEX IF NOT EXISTS idx_doc_status ON documents(status)"))
            
            # æ–‡æ¡£å—ç´¢å¼•
            conn.execute(text("CREATE INDEX IF NOT EXISTS idx_chunk_doc ON document_chunks(document_id)"))
            conn.execute(text("CREATE INDEX IF NOT EXISTS idx_chunk_vector ON document_chunks(vector_id)"))
            
            conn.commit()
        
        print("âœ… ç´¢å¼•åˆ›å»ºæˆåŠŸ")
        
    except Exception as e:
        print(f"âŒ è¡¨åˆ›å»ºå¤±è´¥: {e}")

if __name__ == "__main__":
    create_knowledge_tables()
```

## âœ… éªŒè¯æ­¥éª¤

### 1. è¿è¡Œè¿ç§»è„šæœ¬
```bash
cd backend
python scripts/create_knowledge_tables.py
```

### 2. éªŒè¯è¡¨ç»“æ„
```sql
-- è¿æ¥PostgreSQLéªŒè¯
\d knowledge_bases
\d documents  
\d document_chunks

-- æ£€æŸ¥ç´¢å¼•
\di
```

### 3. æµ‹è¯•æ•°æ®æ’å…¥
```python
# æµ‹è¯•è„šæœ¬
from app.models.database import SessionLocal
from app.models.knowledge import KnowledgeBase
import uuid

db = SessionLocal()
try:
    kb = KnowledgeBase(
        name="æµ‹è¯•çŸ¥è¯†åº“",
        description="è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•çŸ¥è¯†åº“",
        owner_id=str(uuid.uuid4())
    )
    db.add(kb)
    db.commit()
    print(f"âœ… æµ‹è¯•æ•°æ®æ’å…¥æˆåŠŸ: {kb.id}")
finally:
    db.close()
```

## ğŸš¨ å¸¸è§é—®é¢˜

### UUIDç±»å‹é”™è¯¯
```python
# ç¡®ä¿æ­£ç¡®å¯¼å…¥UUIDç±»å‹
from sqlalchemy.dialects.postgresql import UUID
```

### æšä¸¾ç±»å‹é—®é¢˜
```python
# ç¡®ä¿æšä¸¾ç»§æ‰¿æ­£ç¡®çš„åŸºç±»
class DocumentStatus(str, enum.Enum):
    pass
```

### å¤–é”®çº¦æŸé”™è¯¯
```sql
-- æ£€æŸ¥å¤–é”®çº¦æŸ
SELECT * FROM information_schema.table_constraints 
WHERE constraint_type = 'FOREIGN KEY';
```

## â¡ï¸ ä¸‹ä¸€æ­¥
æ•°æ®æ¨¡å‹åˆ›å»ºå®Œæˆåï¼Œç»§ç»­ [çŸ¥è¯†åº“API](./çŸ¥è¯†åº“API.md)
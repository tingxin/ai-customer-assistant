# 智能客服系统实施手册\n\n## 1. 环境准备\n\n### 1.1 系统要求\n- **操作系统**：Linux (Ubuntu 20.04+) / macOS / Windows 10+\n- **Python版本**：3.11+\n- **Node.js版本**：18+\n- **内存要求**：最低8GB，推荐16GB+\n- **存储空间**：最低50GB可用空间\n- **网络要求**：稳定的互联网连接（用于下载依赖和AI模型）\n\n### 1.2 依赖软件安装\n\n#### 1.2.1 安装Docker和Docker Compose\n```bash\n# Ubuntu/Debian\nsudo apt update\nsudo apt install docker.io docker-compose-plugin\nsudo usermod -aG docker $USER\n\n# macOS (使用Homebrew)\nbrew install docker docker-compose\n\n# 验证安装\ndocker --version\ndocker compose version\n```\n\n#### 1.2.2 安装Python和Node.js\n```bash\n# 安装Python 3.11\nsudo apt install python3.11 python3.11-venv python3.11-dev\n\n# 安装Node.js 18\ncurl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n# 验证安装\npython3.11 --version\nnode --version\nnpm --version\n```\n\n## 2. 项目初始化\n\n### 2.1 创建项目目录结构\n```bash\n# 创建项目根目录\nmkdir ai-customer-service\ncd ai-customer-service\n\n# 创建子目录\nmkdir -p backend/app/{api,services,models,knowledge}\nmkdir -p frontend/src/{components,pages,services}\nmkdir -p docs\nmkdir -p data/{uploads,vectors,logs}\nmkdir -p scripts\n\n# 创建必要的空文件\ntouch backend/app/__init__.py\ntouch backend/requirements.txt\ntouch frontend/package.json\ntouch docker-compose.yml\ntouch .env\ntouch README.md\n```\n\n### 2.2 配置环境变量\n创建 `.env` 文件：\n```bash\n# 数据库配置\nPOSTGRES_DB=ai_customer_service\nPOSTGRES_USER=postgres\nPOSTGRES_PASSWORD=your_secure_password\nPOSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\n\n# Redis配置\nREDIS_URL=redis://localhost:6379\n\n# AI模型配置\nOPENAI_API_KEY=your_openai_api_key\nEMBEDDING_MODEL=all-MiniLM-L6-v2\n\n# 应用配置\nSECRET_KEY=your_secret_key_here\nDEBUG=true\nFRONTEND_URL=http://localhost:3000\nBACKEND_URL=http://localhost:8000\n\n# 文件存储\nUPLOAD_DIR=./data/uploads\nVECTOR_DIR=./data/vectors\nLOG_DIR=./data/logs\n```\n\n## 3. 后端实施步骤\n\n### 3.1 创建Python虚拟环境\n```bash\ncd backend\npython3.11 -m venv venv\nsource venv/bin/activate  # Linux/macOS\n# venv\\Scripts\\activate  # Windows\n```\n\n### 3.2 安装Python依赖\n创建 `backend/requirements.txt`：\n```\n# Web框架\nfastapi==0.104.1\nuvicorn[standard]==0.24.0\npython-multipart==0.0.6\n\n# 数据处理\npydantic==2.5.0\npydantic-settings==2.1.0\nsqlalchemy==2.0.23\npsycopg2-binary==2.9.9\nredis==5.0.1\n\n# AI和向量处理\nrag-anything==0.1.0\nlightrag==0.1.0\nchromadb==0.4.15\nsentence-transformers==2.2.2\ntransformers==4.35.0\ntorch==2.1.0\n\n# 文档处理\nPyPDF2==3.0.1\npython-docx==0.8.11\nmarkdown==3.5.1\nbeautifulsoup4==4.12.2\n\n# 工具库\naiofiles==23.2.1\npython-jose[cryptography]==3.3.0\npasslib[bcrypt]==1.7.4\n```\n\n安装依赖：\n```bash\npip install -r requirements.txt\n```\n\n### 3.3 创建后端核心文件\n\n#### 3.3.1 创建主应用文件\n创建 `backend/app/main.py`：\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom app.api.v1 import chat, knowledge, admin\nfrom app.core.config import settings\n\napp = FastAPI(\n    title=\"智能客服系统API\",\n    description=\"基于RAG技术的智能客服系统\",\n    version=\"1.0.0\"\n)\n\n# CORS配置\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=settings.ALLOWED_ORIGINS,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# 静态文件服务\napp.mount(\"/uploads\", StaticFiles(directory=settings.UPLOAD_DIR), name=\"uploads\")\n\n# 注册路由\napp.include_router(chat.router, prefix=\"/api/v1/chat\", tags=[\"chat\"])\napp.include_router(knowledge.router, prefix=\"/api/v1/knowledge\", tags=[\"knowledge\"])\napp.include_router(admin.router, prefix=\"/api/v1/admin\", tags=[\"admin\"])\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"智能客服系统API服务正在运行\", \"version\": \"1.0.0\"}\n\n@app.get(\"/health\")\nasync def health_check():\n    return {\"status\": \"healthy\", \"service\": \"ai-customer-service\"}\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        \"app.main:app\",\n        host=\"0.0.0.0\",\n        port=8000,\n        reload=settings.DEBUG\n    )\n```\n\n#### 3.3.2 创建配置文件\n创建 `backend/app/core/config.py`：\n```python\nfrom pydantic_settings import BaseSettings\nfrom typing import List\nimport os\n\nclass Settings(BaseSettings):\n    # 数据库配置\n    POSTGRES_DB: str = \"ai_customer_service\"\n    POSTGRES_USER: str = \"postgres\"\n    POSTGRES_PASSWORD: str = \"password\"\n    POSTGRES_HOST: str = \"localhost\"\n    POSTGRES_PORT: int = 5432\n    \n    @property\n    def DATABASE_URL(self) -> str:\n        return f\"postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_HOST}:{self.POSTGRES_PORT}/{self.POSTGRES_DB}\"\n    \n    # Redis配置\n    REDIS_URL: str = \"redis://localhost:6379\"\n    \n    # AI配置\n    OPENAI_API_KEY: str = \"\"\n    EMBEDDING_MODEL: str = \"all-MiniLM-L6-v2\"\n    \n    # 应用配置\n    SECRET_KEY: str = \"your-secret-key-change-in-production\"\n    DEBUG: bool = True\n    ALLOWED_ORIGINS: List[str] = [\"http://localhost:3000\"]\n    \n    # 文件存储\n    UPLOAD_DIR: str = \"./data/uploads\"\n    VECTOR_DIR: str = \"./data/vectors\"\n    LOG_DIR: str = \"./data/logs\"\n    \n    # 确保目录存在\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        os.makedirs(self.UPLOAD_DIR, exist_ok=True)\n        os.makedirs(self.VECTOR_DIR, exist_ok=True)\n        os.makedirs(self.LOG_DIR, exist_ok=True)\n    \n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n```\n\n### 3.4 创建数据库模型\n创建 `backend/app/models/database.py`：\n```python\nfrom sqlalchemy import create_engine, Column, String, DateTime, Text, Integer, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom datetime import datetime\nimport uuid\nfrom app.core.config import settings\n\nengine = create_engine(settings.DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    username = Column(String(50), unique=True, nullable=False)\n    email = Column(String(100), unique=True)\n    password_hash = Column(String(255))\n    role = Column(String(20), default=\"user\")\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass Session(Base):\n    __tablename__ = \"sessions\"\n    \n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    user_id = Column(UUID(as_uuid=True), nullable=True)\n    title = Column(String(200))\n    status = Column(String(20), default=\"active\")\n    created_at = Column(DateTime, default=datetime.utcnow)\n    last_activity = Column(DateTime, default=datetime.utcnow)\n\nclass Message(Base):\n    __tablename__ = \"messages\"\n    \n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    session_id = Column(UUID(as_uuid=True), nullable=False)\n    sender_type = Column(String(10), nullable=False)  # 'user', 'ai', 'admin'\n    content = Column(Text, nullable=False)\n    message_type = Column(String(20), default=\"text\")\n    metadata = Column(Text)  # JSON string\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nclass KnowledgeBase(Base):\n    __tablename__ = \"knowledge_bases\"\n    \n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    name = Column(String(100), nullable=False)\n    description = Column(Text)\n    owner_id = Column(UUID(as_uuid=True), nullable=False)\n    status = Column(String(20), default=\"active\")\n    document_count = Column(Integer, default=0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\nclass Document(Base):\n    __tablename__ = \"documents\"\n    \n    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)\n    knowledge_base_id = Column(UUID(as_uuid=True), nullable=False)\n    title = Column(String(200), nullable=False)\n    content = Column(Text)\n    doc_type = Column(String(20), nullable=False)\n    status = Column(String(20), default=\"uploaded\")\n    file_path = Column(String(500))\n    file_size = Column(Integer)\n    metadata = Column(Text)  # JSON string\n    created_at = Column(DateTime, default=datetime.utcnow)\n    processed_at = Column(DateTime)\n\n# 数据库依赖\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# 创建表\ndef create_tables():\n    Base.metadata.create_all(bind=engine)\n```\n\n### 3.5 启动后端服务\n```bash\n# 在backend目录下\nsource venv/bin/activate\n\n# 创建数据库表\npython -c \"from app.models.database import create_tables; create_tables()\"\n\n# 启动开发服务器\nuvicorn app.main:app --reload --host 0.0.0.0 --port 8000\n```\n\n**验证步骤**：\n1. 打开浏览器访问 http://localhost:8000\n2. 访问 http://localhost:8000/docs 查看API文档\n3. 访问 http://localhost:8000/health 检查健康状态\n\n## 4. 前端实施步骤\n\n### 4.1 创建React项目\n```bash\ncd frontend\n\n# 创建React TypeScript项目\nnpx create-react-app . --template typescript\n\n# 安装阿里ChatUI和相关依赖\nnpm install @chatui/core\nnpm install react-markdown react-syntax-highlighter\nnpm install remark-math rehype-katex katex\nnpm install @types/react-syntax-highlighter\n\n# 安装管理界面依赖\nnpm install antd @ant-design/icons\nnpm install react-router-dom @types/react-router-dom\nnpm install axios\nnpm install react-dropzone\n```\n\n### 4.2 创建前端核心文件\n\n#### 4.2.1 更新主App组件\n创建 `frontend/src/App.tsx`：\n```tsx\nimport React from 'react';\nimport { BrowserRouter as Router, Routes, Route } from 'react-router-dom';\nimport ChatPage from './pages/ChatPage';\nimport AdminLogin from './pages/admin/Login';\nimport AdminDashboard from './pages/admin/Dashboard';\nimport KnowledgeManagement from './pages/admin/KnowledgeManagement';\nimport './App.css';\n\nfunction App() {\n  return (\n    <Router>\n      <div className=\"App\">\n        <Routes>\n          {/* 用户端路由 */}\n          <Route path=\"/\" element={<ChatPage />} />\n          \n          {/* 管理员端路由 */}\n          <Route path=\"/admin\" element={<AdminLogin />} />\n          <Route path=\"/admin/dashboard\" element={<AdminDashboard />} />\n          <Route path=\"/admin/knowledge\" element={<KnowledgeManagement />} />\n        </Routes>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n```\n\n#### 4.2.2 创建聊天页面\n创建 `frontend/src/pages/ChatPage.tsx`：\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport Chat, { Bubble, useMessages } from '@chatui/core';\nimport '@chatui/core/dist/index.css';\nimport { ChatService } from '../services/chatService';\nimport RichTextRenderer from '../components/RichTextRenderer';\n\nconst ChatPage: React.FC = () => {\n  const { messages, appendMsg, setTyping } = useMessages([]);\n  const [sessionId, setSessionId] = useState<string>('');\n\n  useEffect(() => {\n    initializeSession();\n  }, []);\n\n  const initializeSession = async () => {\n    try {\n      const session = await ChatService.initSession();\n      setSessionId(session.session_id);\n      \n      // 添加欢迎消息\n      appendMsg({\n        type: 'text',\n        content: { text: '您好！我是智能客服助手 🤖\\n\\n我可以帮您解答各种问题，请告诉我您想了解什么？' },\n        user: { avatar: '🤖' },\n      });\n    } catch (error) {\n      console.error('Failed to initialize session:', error);\n    }\n  };\n\n  const handleSend = async (type: string, val: string) => {\n    if (type === 'text' && val.trim()) {\n      // 添加用户消息\n      appendMsg({\n        type: 'text',\n        content: { text: val },\n        position: 'right',\n      });\n\n      setTyping(true);\n\n      try {\n        const response = await ChatService.sendMessage(sessionId, val);\n        appendMsg({\n          type: 'text',\n          content: { text: response.content },\n          user: { avatar: '🤖' },\n        });\n      } catch (error) {\n        appendMsg({\n          type: 'text',\n          content: { text: '抱歉，服务暂时不可用，请稍后再试。' },\n          user: { avatar: '🤖' },\n        });\n      } finally {\n        setTyping(false);\n      }\n    }\n  };\n\n  const renderMessageContent = (msg: any) => {\n    const { content } = msg;\n    \n    if (msg.user?.avatar === '🤖') {\n      return (\n        <div className=\"ai-message\">\n          <RichTextRenderer content={content.text} />\n        </div>\n      );\n    }\n    \n    return <Bubble content={content.text} />;\n  };\n\n  return (\n    <div style={{ height: '100vh' }}>\n      <Chat\n        navbar={{ \n          title: '智能客服',\n          rightContent: (\n            <div style={{ fontSize: '12px', color: '#52c41a' }}>\n              ● 在线\n            </div>\n          )\n        }}\n        messages={messages}\n        renderMessageContent={renderMessageContent}\n        onSend={handleSend}\n        placeholder=\"请输入您的问题...\"\n        quickReplies={[\n          { name: '产品功能', isNew: true, isHighlight: false },\n          { name: '使用方法', isNew: false, isHighlight: false },\n          { name: '技术支持', isNew: false, isHighlight: false },\n          { name: '常见问题', isNew: false, isHighlight: false },\n        ]}\n        onQuickReplyClick={(item) => handleSend('text', item.name)}\n      />\n    </div>\n  );\n};\n\nexport default ChatPage;\n```\n\n#### 4.2.3 创建API服务\n创建 `frontend/src/services/chatService.ts`：\n```typescript\nimport axios from 'axios';\n\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api/v1';\n\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000,\n});\n\nexport interface SessionResponse {\n  session_id: string;\n  expires_at: string;\n}\n\nexport interface MessageResponse {\n  content: string;\n  message_id: string;\n  timestamp: string;\n}\n\nexport class ChatService {\n  static async initSession(): Promise<SessionResponse> {\n    const response = await apiClient.post('/chat/sessions');\n    return response.data.data;\n  }\n\n  static async sendMessage(sessionId: string, message: string): Promise<MessageResponse> {\n    const response = await apiClient.post('/chat/messages', {\n      session_id: sessionId,\n      message: message,\n    });\n    return response.data.data;\n  }\n\n  static async getSessionHistory(sessionId: string) {\n    const response = await apiClient.get(`/chat/sessions/${sessionId}/messages`);\n    return response.data.data;\n  }\n}\n```\n\n### 4.3 启动前端服务\n```bash\n# 在frontend目录下\nnpm start\n```\n\n**验证步骤**：\n1. 打开浏览器访问 http://localhost:3000\n2. 测试聊天功能是否正常\n3. 检查浏览器控制台是否有错误\n\n## 5. 知识库功能实施\n\n### 5.1 安装知识库依赖\n```bash\n# 在backend目录下，激活虚拟环境\nsource venv/bin/activate\n\n# 安装额外的知识库依赖\npip install rag-anything lightrag chromadb\npip install sentence-transformers transformers torch\n```\n\n### 5.2 创建知识库服务\n创建 `backend/app/services/knowledge_service.py`：\n```python\nfrom typing import List, Dict, Any, Optional\nimport uuid\nfrom datetime import datetime\nimport os\nimport aiofiles\nfrom ..models.database import Document, KnowledgeBase\nfrom ..core.config import settings\n\nclass KnowledgeService:\n    def __init__(self):\n        self.upload_dir = settings.UPLOAD_DIR\n        self.vector_dir = settings.VECTOR_DIR\n        \n        # 确保目录存在\n        os.makedirs(self.upload_dir, exist_ok=True)\n        os.makedirs(self.vector_dir, exist_ok=True)\n    \n    async def upload_document(self, file_content: bytes, filename: str, \n                            doc_type: str, knowledge_base_id: str,\n                            category: Optional[str] = None, \n                            tags: List[str] = None) -> str:\n        \"\"\"上传并处理文档\"\"\"\n        # 生成文档ID\n        doc_id = str(uuid.uuid4())\n        \n        # 保存文件\n        file_path = os.path.join(self.upload_dir, f\"{doc_id}_{filename}\")\n        async with aiofiles.open(file_path, 'wb') as f:\n            await f.write(file_content)\n        \n        # 创建文档记录（这里需要数据库操作）\n        # 实际实现中需要使用SQLAlchemy进行数据库操作\n        \n        return doc_id\n    \n    async def process_document(self, doc_id: str):\n        \"\"\"处理文档：解析 + 向量化\"\"\"\n        # 这里实现文档处理逻辑\n        # 1. 使用RAG-Anything解析文档\n        # 2. 使用LightRAG向量化\n        # 3. 存储到向量数据库\n        pass\n    \n    async def search_knowledge(self, query: str, knowledge_base_id: str, \n                             top_k: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"搜索知识库\"\"\"\n        # 这里实现知识检索逻辑\n        # 1. 向量化查询\n        # 2. 相似度搜索\n        # 3. 返回结果\n        return []\n```\n\n### 5.3 创建知识库API\n创建 `backend/app/api/v1/knowledge.py`：\n```python\nfrom fastapi import APIRouter, UploadFile, File, HTTPException, Depends\nfrom typing import List, Optional\nfrom sqlalchemy.orm import Session\nfrom ...models.database import get_db\nfrom ...services.knowledge_service import KnowledgeService\n\nrouter = APIRouter()\nknowledge_service = KnowledgeService()\n\n@router.post(\"/bases\")\nasync def create_knowledge_base(\n    name: str,\n    description: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    \"\"\"创建知识库\"\"\"\n    # 实现创建知识库逻辑\n    return {\"message\": \"Knowledge base created successfully\"}\n\n@router.get(\"/bases\")\nasync def list_knowledge_bases(db: Session = Depends(get_db)):\n    \"\"\"获取知识库列表\"\"\"\n    # 实现获取知识库列表逻辑\n    return {\"data\": []}\n\n@router.post(\"/bases/{kb_id}/documents/upload\")\nasync def upload_document(\n    kb_id: str,\n    file: UploadFile = File(...),\n    doc_type: str = \"auto\",\n    category: Optional[str] = None,\n    tags: Optional[str] = None\n):\n    \"\"\"上传文档到知识库\"\"\"\n    try:\n        content = await file.read()\n        tag_list = tags.split(\",\") if tags else []\n        \n        doc_id = await knowledge_service.upload_document(\n            content, file.filename, doc_type, kb_id, category, tag_list\n        )\n        \n        return {\n            \"success\": True,\n            \"data\": {\"document_id\": doc_id},\n            \"message\": \"Document uploaded successfully\"\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.post(\"/search\")\nasync def search_knowledge(\n    query: str,\n    knowledge_base_id: str,\n    top_k: int = 5\n):\n    \"\"\"搜索知识库\"\"\"\n    try:\n        results = await knowledge_service.search_knowledge(\n            query, knowledge_base_id, top_k\n        )\n        return {\n            \"success\": True,\n            \"data\": {\"results\": results},\n            \"message\": \"Search completed\"\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n```\n\n## 6. Docker部署实施\n\n### 6.1 创建Docker配置文件\n\n#### 6.1.1 后端Dockerfile\n创建 `backend/Dockerfile`：\n```dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# 安装系统依赖\nRUN apt-get update && apt-get install -y \\\n    build-essential \\\n    curl \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 复制并安装Python依赖\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# 复制应用代码\nCOPY app/ ./app/\n\n# 创建必要目录\nRUN mkdir -p data/uploads data/vectors data/logs\n\n# 暴露端口\nEXPOSE 8000\n\n# 启动命令\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n#### 6.1.2 前端Dockerfile\n创建 `frontend/Dockerfile`：\n```dockerfile\n# 构建阶段\nFROM node:18-alpine as build\n\nWORKDIR /app\n\n# 复制package文件\nCOPY package*.json ./\n\n# 安装依赖\nRUN npm ci --only=production\n\n# 复制源代码\nCOPY . .\n\n# 构建应用\nRUN npm run build\n\n# 生产阶段\nFROM nginx:alpine\n\n# 复制构建结果\nCOPY --from=build /app/build /usr/share/nginx/html\n\n# 复制nginx配置\nCOPY nginx.conf /etc/nginx/nginx.conf\n\n# 暴露端口\nEXPOSE 80\n\n# 启动nginx\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n#### 6.1.3 Docker Compose配置\n创建 `docker-compose.yml`：\n```yaml\nversion: '3.8'\n\nservices:\n  # PostgreSQL数据库\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: ${POSTGRES_DB}\n      POSTGRES_USER: ${POSTGRES_USER}\n      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${POSTGRES_USER}\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # Redis缓存\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # ChromaDB向量数据库\n  chromadb:\n    image: chromadb/chroma:latest\n    ports:\n      - \"8001:8000\"\n    volumes:\n      - chroma_data:/chroma/chroma\n    environment:\n      - CHROMA_SERVER_HOST=0.0.0.0\n      - CHROMA_SERVER_HTTP_PORT=8000\n\n  # 后端服务\n  backend:\n    build: ./backend\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}\n      - REDIS_URL=redis://redis:6379\n      - CHROMA_URL=http://chromadb:8000\n    volumes:\n      - ./data:/app/data\n      - ./backend/app:/app/app\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_healthy\n      chromadb:\n        condition: service_started\n    restart: unless-stopped\n\n  # 前端服务\n  frontend:\n    build: ./frontend\n    ports:\n      - \"3000:80\"\n    environment:\n      - REACT_APP_API_URL=http://localhost:8000/api/v1\n    depends_on:\n      - backend\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  redis_data:\n  chroma_data:\n```\n\n### 6.2 部署命令\n```bash\n# 构建并启动所有服务\ndocker compose up --build -d\n\n# 查看服务状态\ndocker compose ps\n\n# 查看日志\ndocker compose logs -f backend\ndocker compose logs -f frontend\n\n# 停止服务\ndocker compose down\n\n# 完全清理（包括数据卷）\ndocker compose down -v\n```\n\n## 7. 测试验证步骤\n\n### 7.1 后端API测试\n```bash\n# 测试健康检查\ncurl http://localhost:8000/health\n\n# 测试创建会话\ncurl -X POST \"http://localhost:8000/api/v1/chat/sessions\" \\\n     -H \"Content-Type: application/json\"\n\n# 测试发送消息\ncurl -X POST \"http://localhost:8000/api/v1/chat/messages\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"session_id\": \"your-session-id\", \"message\": \"你好\"}'\n\n# 测试知识库创建\ncurl -X POST \"http://localhost:8000/api/v1/knowledge/bases\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"name\": \"测试知识库\", \"description\": \"这是一个测试知识库\"}'\n```\n\n### 7.2 前端功能测试\n1. **聊天功能测试**：\n   - 访问 http://localhost:3000\n   - 测试发送消息\n   - 测试快速回复按钮\n   - 测试富文本渲染\n\n2. **管理界面测试**：\n   - 访问 http://localhost:3000/admin\n   - 测试知识库管理\n   - 测试文档上传\n   - 测试系统监控\n\n### 7.3 集成测试\n```bash\n# 创建测试脚本\ncat > test_integration.sh << 'EOF'\n#!/bin/bash\n\necho \"开始集成测试...\"\n\n# 测试后端健康状态\necho \"测试后端健康状态...\"\nresponse=$(curl -s http://localhost:8000/health)\nif [[ $response == *\"healthy\"* ]]; then\n    echo \"✅ 后端服务正常\"\nelse\n    echo \"❌ 后端服务异常\"\n    exit 1\nfi\n\n# 测试前端访问\necho \"测试前端访问...\"\nstatus_code=$(curl -s -o /dev/null -w \"%{http_code}\" http://localhost:3000)\nif [[ $status_code == \"200\" ]]; then\n    echo \"✅ 前端服务正常\"\nelse\n    echo \"❌ 前端服务异常\"\n    exit 1\nfi\n\n# 测试数据库连接\necho \"测试数据库连接...\"\n# 这里可以添加数据库连接测试\n\necho \"✅ 所有测试通过！\"\nEOF\n\nchmod +x test_integration.sh\n./test_integration.sh\n```\n\n## 8. 运维和监控\n\n### 8.1 日志管理\n```bash\n# 查看实时日志\ndocker compose logs -f backend\ndocker compose logs -f frontend\n\n# 查看特定时间段的日志\ndocker compose logs --since=\"2024-01-01T00:00:00\" backend\n\n# 导出日志到文件\ndocker compose logs backend > backend.log\n```\n\n### 8.2 性能监控\n```bash\n# 查看容器资源使用情况\ndocker stats\n\n# 查看系统资源\ntop\nhtop\ndf -h\n```\n\n### 8.3 备份和恢复\n```bash\n# 数据库备份\ndocker compose exec postgres pg_dump -U postgres ai_customer_service > backup.sql\n\n# 数据库恢复\ndocker compose exec -T postgres psql -U postgres ai_customer_service < backup.sql\n\n# 文件数据备份\ntar -czf data_backup.tar.gz ./data/\n```\n\n## 9. 故障排除\n\n### 9.1 常见问题\n\n#### 9.1.1 后端启动失败\n```bash\n# 检查端口占用\nlsof -i :8000\n\n# 检查Python依赖\npip list\n\n# 检查环境变量\nenv | grep -E \"POSTGRES|REDIS|OPENAI\"\n```\n\n#### 9.1.2 前端构建失败\n```bash\n# 清理node_modules\nrm -rf node_modules package-lock.json\nnpm install\n\n# 检查Node.js版本\nnode --version\nnpm --version\n```\n\n#### 9.1.3 数据库连接失败\n```bash\n# 检查PostgreSQL状态\ndocker compose ps postgres\n\n# 测试数据库连接\ndocker compose exec postgres psql -U postgres -d ai_customer_service -c \"SELECT 1;\"\n```\n\n### 9.2 性能优化\n\n#### 9.2.1 后端优化\n```python\n# 在app/main.py中添加\nfrom fastapi.middleware.gzip import GZipMiddleware\n\napp.add_middleware(GZipMiddleware, minimum_size=1000)\n```\n\n#### 9.2.2 数据库优化\n```sql\n-- 添加索引\nCREATE INDEX idx_messages_session_id ON messages(session_id);\nCREATE INDEX idx_documents_knowledge_base_id ON documents(knowledge_base_id);\nCREATE INDEX idx_sessions_user_id ON sessions(user_id);\n```\n\n## 10. 开发者协作指南\n\n### 10.1 开发环境配置\n每个开发者需要执行以下步骤：\n\n```bash\n# 1. 克隆项目\ngit clone <repository-url>\ncd ai-customer-service\n\n# 2. 复制环境变量模板\ncp .env.example .env\n# 编辑.env文件，填入实际配置\n\n# 3. 启动开发环境\ndocker compose -f docker-compose.dev.yml up -d\n\n# 4. 安装前端依赖\ncd frontend\nnpm install\nnpm start\n\n# 5. 安装后端依赖\ncd ../backend\npython -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\nuvicorn app.main:app --reload\n```\n\n### 10.2 代码提交规范\n```bash\n# 提交格式\ngit commit -m \"<type>(<scope>): <description>\"\n\n# 示例\ngit commit -m \"feat(chat): 添加语音输入功能\"\ngit commit -m \"fix(knowledge): 修复文档上传bug\"\ngit commit -m \"docs(readme): 更新部署文档\"\n```\n\n### 10.3 分支管理\n- `main`: 主分支，用于生产环境\n- `develop`: 开发分支，用于集成测试\n- `feature/*`: 功能分支，用于开发新功能\n- `hotfix/*`: 热修复分支，用于紧急修复\n\n通过以上实施手册，运维工程师可以按步骤完成整个智能客服系统的部署和配置，确保系统正常运行。